/**
* multiproject-git-gradle/build.gradle
*
* Gradle script automating git-clone/pull and compilation of multiple 
* inter-connected projects.
*
* Written by Andrey Hihlovskiy (akhikhl AT gmail DOT com).
* Licensed under the MIT (http://opensource.org/licenses/MIT).
* Date: 13.06.2013
*
* @author Andrey Hihlovskiy
* @version 1.0.0
* @requires gradle 1.6, git 1.7
*
* Full documentation and sources at:
* https://github.com/akhikhl/multiproject-git-gradle
**/

buildscript {
  repositories { mavenCentral() }
  dependencies { classpath 'org.ajoberstar:gradle-git:0.5.0' }
}

import org.ajoberstar.gradle.git.tasks.*

class MultiProjectExtension {
  String rootFolder
  String gitBase
  def projects = [:];
  def project(proj) {
    String projName = proj instanceof String ? proj : proj.name
    if(projects.containsKey(projName))
      throw new Exception("Duplicate project definition: $projName");
    if(proj instanceof String)
      proj = [ name: proj ];
    projects[projName] = proj
  }
}

project.extensions.create "multiproject", MultiProjectExtension
  
apply from: "config.gradle"

if(project.ext.has("extraConfig")) {
  def extraConfigs = project.ext.extraConfig.split(",")
  for(def extraConfig in extraConfigs) {
    if(!extraConfig.endsWith(".gradle"))
      extraConfig += ".gradle";
    apply from: extraConfig
  }
}

task build
task buildExamples
task gitBranchList
task gitStatus
task update
task uploadArchives

if(!tasks.findByName("clean"))
  task clean

def rootFolder = project.multiproject.rootFolder ? new File(project.projectDir, project.multiproject.rootFolder).canonicalFile : new File(project.projectDir)

def isCollection(obj) {
  return [Collection, Object[]].any { it.isAssignableFrom(obj.getClass()) }
}

def toCollection(obj) {
  return isCollection(obj) ? obj : [ obj ]
}

for(def e in project.multiproject.projects) {  
  String projName = e.key
  def proj = e.value  
  File projFolder = new File(rootFolder, projName)
  
  def projUpdateTask;
  if(projFolder.exists()) {
    projUpdateTask = task(projName + "_update", type: GitPull) {
      repoPath = projFolder.absolutePath
    }
    if(proj.branch)
      task(projName + "_checkout", type: GitCheckout) { task ->
        repoPath = projFolder.absolutePath
        branchName = proj.branch
        projUpdateTask.dependsOn task
      }
  } else {
    def gitSource
    if(proj.gitSource)
      gitSource = proj.gitSource 
    else {
      def gitName = proj.gitName ? proj.gitName : projName + ".git"      
      def gitBase
      if(proj.gitBase)
        gitBase = proj.gitBase
      else if(project.multiproject.gitBase)
        gitBase = project.multiproject.gitBase
      else
        throw new Exception("Don't know from where to clone project '$projName'. Please specify gitBase or gitSource.");
      gitSource = gitBase
      if(!gitSource.endsWith("/"))
        gitSource += "/"
      gitSource += gitName
    }
    projUpdateTask = task(projName + "_update", type: GitClone) {
      destinationPath = projFolder.absolutePath
      uri = gitSource
      if(proj.branch) {
        checkout = true
        branch = proj.branch
      }
    }
  }  
  update.dependsOn projUpdateTask
  
  def projBuildTask = null
  def projCleanTask = null
  if(proj.build) {
    projBuildTask = task(projName + "_build", type: GradleBuild) { task ->
      if(proj.build instanceof String) {
        if(proj.build.endsWith(".gradle"))
          buildFile = "$projFolder/${proj.build}"
        else
          dir = "$projFolder/${proj.build}"
      }
      else
        dir = projFolder
      tasks = proj.buildTasks ? proj.buildTasks : [ "build" ]
      build.dependsOn task
      if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
    projCleanTask = task(projName + "_clean", type: GradleBuild) { task ->
      dir = new File(projFolder, proj.build instanceof String ? proj.build : ".")
      tasks = [ "clean" ]
      clean.dependsOn task
      if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
  } else if(!projFolder.exists()) {
    build.dependsOn projUpdateTask
    clean.dependsOn projUpdateTask
  }

  if(proj.examples)
    task(projName + "_buildExamples", type: GradleBuild) { task ->
      dir = new File(projFolder, proj.examples instanceof String ? proj.examples : "examples")
      tasks = [ "build" ]
      dependsOn build
      buildExamples.dependsOn task
      if(projBuildTask)
        dependsOn projBuildTask
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
    }

  if(proj.uploadArchives)
    task(projName + "_uploadArchives", type: GradleBuild) { task ->
      dir = new File(projFolder, proj.build instanceof String ? proj.build : ".")
      tasks = [ "uploadArchives" ]
      dependsOn build
      uploadArchives.dependsOn task
      if(projBuildTask)
        dependsOn projBuildTask
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
    }

  task(projName + "_gitStatus", type: GitStatus) { task ->
    description = "git status on " + projName
    repoPath = projFolder.absolutePath
    doLast {
      [ "added", "changed", "conflicting", "missing", "modified", "removed", "untracked" ].each { fileSetName ->
        task[fileSetName].files.each { file ->
          println "${fileSetName}: ${file.absolutePath}"
        }
      }
      task.untrackedDirs.files.each { file ->
        if(!task.ignored.files.contains(file))
          println "untracked dir: " + file.absolutePath
      }
    }
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitStatus.dependsOn task
  }

  task(projName + "_gitBranchList", type: GitBranchList) { task ->
    description = "git branches on " + projName
    repoPath = projFolder.absolutePath
    doLast {
      branches.each { branch ->
        if(branch.name == workingBranch.name)
          print "* "
        println branch.name
      }
    }
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitBranchList.dependsOn task
  }  
}

// second pass, now we handle inter-project dependencies
for(def e in project.multiproject.projects) {
  def projName = e.key
  def proj = e.value
  if(proj.dependsOn) {
    def thisProjUpdate = tasks[projName + "_update"]
    def thisProjBuild = tasks.findByName(projName + "_build")
    def thisProjClean = tasks.findByName(projName + "_clean")
    def thisProjGitStatus = tasks[projName + "_gitStatus"]
    toCollection(proj.dependsOn).each { otherProj ->
      def otherProjUpdate = otherProj + "_update"
      thisProjUpdate.dependsOn otherProjUpdate
      if(thisProjBuild) {
        def otherProjBuild = tasks.findByName(otherProj + "_build")
        if(otherProjBuild)
          thisProjBuild.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuild.dependsOn otherProjUpdate
      }
      if(thisProjClean) {
        def otherProjClean = tasks.findByName(otherProj + "_clean")
        if(otherProjClean)
          thisProjClean.dependsOn otherProjClean
        else if (!file(otherProj).exists())
          thisProjClean.dependsOn otherProjUpdate
      }
      thisProjGitStatus.dependsOn otherProj + "_gitStatus"
    }
  }
}

defaultTasks "build"

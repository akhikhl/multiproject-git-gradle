/**
* multiproject-git-gradle/build.gradle
*
* Gradle script automating git-clone/pull and compilation of multiple 
* inter-connected projects.
*
* Written by Andrey Hihlovskiy (akhikhl AT gmail DOT com).
* Licensed under the MIT (http://opensource.org/licenses/MIT).
* Date: 13.06.2013
*
* @author Andrey Hihlovskiy
* @version 1.0.9
* @requires gradle 1.8+, git 1.8+
*
* Full documentation and sources at:
* https://github.com/akhikhl/multiproject-git-gradle
**/

buildscript {
  repositories { mavenCentral() }
  dependencies { classpath 'org.ajoberstar:gradle-git:0.6.3' }
}

import org.ajoberstar.gradle.git.tasks.*

class MultiProjectExtension {
  String rootFolder
  def projects = [:]
  String gitBase
  String gitNameSeparator = '/'
  String gitNameSuffix = '.git'
  def git(Map options = [:], Closure closure) {
    def savedGitBase = gitBase
    gitBase = options.baseUrl
    def savedGitNameSeparator = gitNameSeparator
    gitNameSeparator = options.nameSeparator ?: options.gitNameSeparator ?: gitNameSeparator 
    def savedGitNameSuffix = gitNameSuffix
    gitNameSuffix = options.nameSuffix ?: options.gitNameSuffix ?: gitNameSuffix
    closure.delegate = this
    closure()
    gitNameSuffix = savedGitNameSuffix
    gitNameSeparator = savedGitNameSeparator
    gitBase = savedGitBase
  }
  def project(proj) {
    String projName = isString(proj) ? proj : proj.name
    if(projects.containsKey(projName))
      throw new Exception("Duplicate project definition: $projName")
    if(isString(proj))
      proj = [ name: proj as String ]
    if(!proj.gitBase && !proj.gitSource)
      proj.gitBase = gitBase
    if(!proj.gitNameSeparator && !proj.gitSource)
      proj.gitNameSeparator = gitNameSeparator
    if(!proj.gitNameSuffix && !proj.gitSource)
      proj.gitNameSuffix = gitNameSuffix
    projects[projName] = proj
  }
  boolean isString(x) { 
    x instanceof String || x instanceof GString 
  }  
}

boolean isString(x) { 
  x instanceof String || x instanceof GString 
}

project.extensions.create 'multiproject', MultiProjectExtension
  
apply from: 'config.gradle'

if(project.ext.has('extraConfig')) {
  def extraConfigs = project.ext.extraConfig.split(',')
  for(def extraConfig in extraConfigs) {
    if(!extraConfig.endsWith('.gradle'))
      extraConfig += '.gradle'
    apply from: extraConfig
  }
}

task build
task buildExamples
task buildApps
task gitBranchList
task gitStatus
task update
task uploadArchives

if(!tasks.findByName('clean'))
  task clean

clean.mustRunAfter update

def rootFolder = (project.multiproject.rootFolder ? new File(project.projectDir, project.multiproject.rootFolder).canonicalFile : project.projectDir)

def isCollection(obj) {
  return [Collection, Object[]].any { it.isAssignableFrom(obj.getClass()) }
}

def toCollection(obj) {
  return isCollection(obj) ? obj : [ obj ]
}

for(def e in project.multiproject.projects) {  
  String projName = e.key
  def proj = e.value  
  File projFolder = new File(rootFolder, new File(projName).getName())
  
  def projUpdateTask
  if(projFolder.exists()) {
    projUpdateTask = task("${projName}_update", type: GitPull) {
      repoPath = projFolder.absolutePath
    }
    if(proj.branch)
      task("${projName}_checkout", type: GitCheckout) { task ->
        repoPath = projFolder.absolutePath
        branchName = proj.branch
        projUpdateTask.dependsOn task
      }
  } else {
    def gitSource
    if(proj.gitSource)
      gitSource = proj.gitSource 
    else {
      def gitName = proj.gitName ?: projName
      gitName += proj.gitNameSuffix      
      def gitBase
      if(proj.gitBase)
        gitBase = proj.gitBase
      else if(project.multiproject.gitBase)
        gitBase = project.multiproject.gitBase
      else
        throw new Exception("Don't know from where to clone project '$projName'. Please specify gitBase or gitSource.")
      gitSource = gitBase
      gitSource += proj.gitNameSeparator
      gitSource += gitName
    }
    projUpdateTask = task("${projName}_update", type: GitClone) {
      destinationPath = projFolder.absolutePath
      uri = gitSource
      if(proj.branch) {
        checkout = true
        branch = proj.branch
      }
    }
  }  
  update.dependsOn projUpdateTask
  
  boolean shouldBuild = proj.build == null || proj.build
  boolean buildSelfDefined = proj.build == null || (proj.build instanceof Boolean && proj.build)
  def projBuildTask = null
  def projCleanTask = null
  if(shouldBuild) {
    projBuildTask = task("${projName}_build", type: GradleBuild) { task ->
      if(buildSelfDefined)
        dir = projFolder
      else {
        proj.build = proj.build.toString()
        if(proj.build.endsWith('.gradle'))
          buildFile = "$projFolder/${proj.build}"
        else
          dir = "$projFolder/${proj.build}"
      }
      tasks = proj.buildTasks ? proj.buildTasks : [ 'build' ]
      build.dependsOn task
      if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
    projCleanTask = task("${projName}_clean", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.build) ? proj.build : '.')
      tasks = [ 'clean' ]
      clean.dependsOn task
      if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
    if(proj.contribs) {
      task("${projName}_installContribs", type: GradleBuild) { task ->
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'install' ]
        projBuildTask.dependsOn task
        if(projFolder.exists())
          task.mustRunAfter projUpdateTask
        else
          task.dependsOn projUpdateTask      
      }
      task("${projName}_cleanContribs", type: GradleBuild) { task ->
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'clean' ]
        clean.dependsOn task
        task.dependsOn projCleanTask
        if(projFolder.exists())
          task.mustRunAfter projUpdateTask
        else
          task.dependsOn projUpdateTask      
      }
    }
  } else if(!projFolder.exists()) {
    build.dependsOn projUpdateTask
    clean.dependsOn projUpdateTask
  }

  if(proj.examples) {
    task("${projName}_buildExamples", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.examples) ? proj.examples : 'examples')
      tasks = [ 'build' ]
      task.dependsOn build
      buildExamples.dependsOn task
      if(projBuildTask)
        task.dependsOn projBuildTask
      else if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask      
    }

    task("${projName}_cleanExamples", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.examples) ? proj.examples : 'examples')
      tasks = [ 'clean' ]
      clean.dependsOn task
      if(projCleanTask)
        projCleanTask.dependsOn task
      else if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
  }
  
  if(proj.apps) {
    task("${projName}_buildApps", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.apps) ? proj.apps : 'apps')
      tasks = [ 'build' ]
      dependsOn build
      buildApps.dependsOn task
      if(projBuildTask)
        task.dependsOn projBuildTask
      else if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }

    task("${projName}_cleanApps", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.apps) ? proj.apps : 'apps')
      tasks = [ 'clean' ]
      clean.dependsOn task
      if(projCleanTask)
        projCleanTask.dependsOn task
      else if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
  }

  if(proj.uploadArchives || buildSelfDefined) {
    def uploadArchivesTask = task("${projName}_uploadArchives", type: GradleBuild) { task ->
      dir = new File(projFolder, isString(proj.build) ? proj.build : '.')
      tasks = [ 'uploadArchives' ]
      dependsOn build
      uploadArchives.dependsOn task
      if(projBuildTask)
        task.dependsOn projBuildTask
      else if(projFolder.exists())
        task.mustRunAfter projUpdateTask
      else
        task.dependsOn projUpdateTask
    }
    if(proj.contribs)
      task("${projName}_uploadContribs", type: GradleBuild) { task ->
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'uploadArchives' ]
        uploadArchivesTask.dependsOn task
        if(projFolder.exists())
          task.mustRunAfter projUpdateTask
        else
          task.dependsOn projUpdateTask      
      }
  }

  task("${projName}_gitStatus", type: GitStatus) { task ->
    description = "git status on ${projName}"
    repoPath = projFolder.absolutePath
    doLast {
      [ 'added', 'changed', 'conflicting', 'missing', 'modified', 'removed', 'untracked' ].each { fileSetName ->
        task[fileSetName].files.each { file ->
          println "${fileSetName}: ${file.absolutePath}"
        }
      }
      task.untrackedDirs.files.each { file ->
        if(!task.ignored.files.contains(file))
          println "untracked dir: ${file.absolutePath}"
      }
    }
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitStatus.dependsOn task
  }

  task("${projName}_gitBranchList", type: GitBranchList) { task ->
    description = "git branches on ${projName}"
    repoPath = projFolder.absolutePath
    doLast {
      branches.each { branch ->
        if(branch.name == workingBranch.name)
          print '* '
        println branch.name
      }
    }
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitBranchList.dependsOn task
  }  
}

// second pass, now we handle inter-project dependencies
for(def e in project.multiproject.projects) {
  def projName = e.key
  def proj = e.value
  if(proj.dependsOn) {
    def thisProjUpdate = tasks.findByName("${projName}_update")
    def thisProjBuild = tasks.findByName("${projName}_build")
    def thisProjBuildExamples = tasks.findByName("${projName}_buildExamples")
    def thisProjBuildApps = tasks.findByName("${projName}_buildApps")
    def thisProjClean = tasks.findByName("${projName}_clean")
    def thisProjGitStatus = tasks.findByName("${projName}_gitStatus")
    toCollection(proj.dependsOn).each { otherProj ->
      def otherProjUpdate = "${otherProj}_update"
      thisProjUpdate.dependsOn otherProjUpdate
      if(thisProjBuild) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuild.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuild.dependsOn otherProjUpdate
      }
      if(thisProjBuildExamples) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuildExamples.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuildExamples.dependsOn otherProjUpdate
      }
      if(thisProjBuildApps) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuildApps.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuildApps.dependsOn otherProjUpdate
      }
      if(thisProjClean) {
        def otherProjClean = tasks.findByName("${otherProj}_clean")
        if(otherProjClean)
          thisProjClean.dependsOn otherProjClean
        else if (!file(otherProj).exists())
          thisProjClean.dependsOn otherProjUpdate
      }
      thisProjGitStatus.dependsOn "${otherProj}_gitStatus"
    }
  }
}

defaultTasks 'buildApps'
